

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boofun.analysis.decision_trees &mdash; BooFun 1.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6efca38a"></script>
      <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BooFun
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guides:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/spectral_analysis.html">Spectral Analysis Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/query_complexity.html">Query Complexity Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/hypercontractivity.html">Hypercontractivity Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/cryptographic.html">Cryptographic Analysis Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/learning.html">Learning Theory Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/representations.html">Representations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/operations.html">Function Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/families.html">Function Families and Growth Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/probabilistic.html">Probabilistic View &amp; Pseudorandomness</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/advanced.html">Advanced Topics Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/migration_from_tal.html">Migration from Tal’s BooleanFunc.py</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../comparison_guide.html">Library Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance.html">Performance Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../error_handling.html">Error Handling in BooFun</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cross_validation.html">Cross-Validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING.html">Contributing to BooFun</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../STYLE_GUIDE.html">BooFun Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../TEST_GUIDELINES.html">Test Guidelines</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/boofun.html">boofun</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BooFun</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../boofun.html">boofun</a></li>
          <li class="breadcrumb-item"><a href="../analysis.html">boofun.analysis</a></li>
      <li class="breadcrumb-item active">boofun.analysis.decision_trees</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boofun.analysis.decision_trees</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Decision tree analysis for Boolean functions.</span>

<span class="sd">This module implements algorithms for analyzing decision tree complexity,</span>
<span class="sd">including dynamic programming approaches for computing optimal trees and</span>
<span class="sd">game-theoretic analysis for randomized complexity.</span>

<span class="sd">The algorithms in this module are based on Avishay Tal&#39;s PhD-era library,</span>
<span class="sd">with modernized implementations, type hints, and documentation.</span>

<span class="sd">Key concepts:</span>
<span class="sd">- D(f): Deterministic decision tree depth (worst-case)</span>
<span class="sd">- D_avg(f): Average-case decision tree depth under uniform distribution</span>
<span class="sd">- D_μ(f): Average-case under arbitrary distribution μ</span>
<span class="sd">- R(f): Randomized decision tree complexity (via minimax theorem)</span>

<span class="sd">The core insight is that decision trees correspond to subcubes of {0,1}^n,</span>
<span class="sd">and we can use dynamic programming over the &quot;cube lattice&quot; where each</span>
<span class="sd">node represents a partial assignment (some variables fixed, others free).</span>

<span class="sd">References:</span>
<span class="sd">- Tal&#39;s PhD library (BooleanFunc.py)</span>
<span class="sd">- Buhrman &amp; de Wolf, &quot;Complexity Measures and Decision Tree Complexity&quot; (2002)</span>
<span class="sd">- O&#39;Donnell, &quot;Analysis of Boolean Functions&quot; (2014), Chapter 1</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">..core.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BooleanFunction</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Core algorithms</span>
    <span class="s2">&quot;decision_tree_depth_dp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;decision_tree_depth_uniform_dp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;decision_tree_depth_weighted_dp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;decision_tree_size_dp&quot;</span><span class="p">,</span>
    <span class="c1"># Tree enumeration</span>
    <span class="s2">&quot;enumerate_decision_trees&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count_decision_trees&quot;</span><span class="p">,</span>
    <span class="c1"># Randomized complexity</span>
    <span class="s2">&quot;randomized_complexity_matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_randomized_complexity&quot;</span><span class="p">,</span>
    <span class="c1"># Tree representation</span>
    <span class="s2">&quot;DecisionTree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;reconstruct_tree&quot;</span><span class="p">,</span>
    <span class="c1"># Utilities</span>
    <span class="s2">&quot;tree_depth&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tree_size&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="DecisionTree">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DecisionTree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a decision tree for a Boolean function.</span>

<span class="sd">    A decision tree is either:</span>
<span class="sd">    - A leaf with a constant output (0 or 1)</span>
<span class="sd">    - An internal node that queries variable `var` and branches to</span>
<span class="sd">      `left` (var=0) or `right` (var=1) subtrees</span>

<span class="sd">    Attributes:</span>
<span class="sd">        var: Variable index to query (-1 for leaf nodes)</span>
<span class="sd">        left: Left subtree (when var=0), or None for leaves</span>
<span class="sd">        right: Right subtree (when var=1), or None for leaves</span>
<span class="sd">        value: Output value for leaf nodes (0 or 1), None for internal nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">var</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DecisionTree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DecisionTree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="DecisionTree.is_leaf">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.is_leaf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if this is a leaf node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span></div>


<div class="viewcode-block" id="DecisionTree.depth">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the depth (longest root-to-leaf path) of this tree.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">left_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">right_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span></div>


<div class="viewcode-block" id="DecisionTree.size">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the size (number of leaves) of this tree.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">left_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">right_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">left_size</span> <span class="o">+</span> <span class="n">right_size</span></div>


<div class="viewcode-block" id="DecisionTree.evaluate">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the decision tree on input x.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Input as integer (bit i = value of variable i)</span>
<span class="sd">            n_vars: Number of variables</span>

<span class="sd">        Returns:</span>
<span class="sd">            Output value (0 or 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="DecisionTree.query_depth">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.query_depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of queries made to evaluate x.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Input as integer</span>
<span class="sd">            n_vars: Number of variables</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of queries (depth of path to leaf)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">query_depth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">query_depth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="DecisionTree.to_dict">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.DecisionTree.to_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert tree to dictionary representation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;leaf&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;internal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
            <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Leaf(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node(x</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="si">}</span><span class="s2">)&quot;</span></div>



<div class="viewcode-block" id="tree_depth">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.tree_depth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tree_depth</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the depth of a decision tree.</span>

<span class="sd">    Handles both DecisionTree objects and list/tuple representations</span>
<span class="sd">    from Tal&#39;s original code: [var, left_subtree, right_subtree] or [].</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: Decision tree in any supported format</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tree depth (longest root-to-leaf path)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span>

    <span class="c1"># Handle list/tuple format from Tal&#39;s code</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span> <span class="ow">or</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">tree_depth</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">tree_depth</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="tree_size">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.tree_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tree_size</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the size (number of leaves) of a decision tree.</span>

<span class="sd">    Args:</span>
<span class="sd">        tree: Decision tree in any supported format</span>

<span class="sd">    Returns:</span>
<span class="sd">        Number of leaves</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span> <span class="ow">or</span> <span class="n">tree</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">return</span> <span class="n">tree_size</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">tree_size</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="decision_tree_depth_dp">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.decision_tree_depth_dp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decision_tree_depth_dp</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute optimal decision tree depth using dynamic programming.</span>

<span class="sd">    This implements Tal&#39;s `calc_decision_tree_DP` algorithm which uses</span>
<span class="sd">    a clever representation of subcubes. Each subcube is encoded using</span>
<span class="sd">    a ternary representation where each variable can be:</span>
<span class="sd">    - 0: fixed to 0</span>
<span class="sd">    - 1: fixed to 1</span>
<span class="sd">    - 2: free (not yet queried)</span>

<span class="sd">    The DP computes the optimal depth for each subcube bottom-up,</span>
<span class="sd">    from fully-specified inputs to the full hypercube.</span>

<span class="sd">    Time complexity: O(3^n) where n is number of variables.</span>
<span class="sd">    Space complexity: O(3^n)</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optimal decision tree depth D(f)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># Get truth table</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Phase 1: Build the cube averages</span>
    <span class="c1"># old_layer[x] = fraction of 1s in subcube corresponding to x</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="n">truth_table</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">new_layer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_layer</span><span class="p">)):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>

            <span class="c1"># Index where variable i has value ind</span>
            <span class="n">new_ind1</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>
            <span class="c1"># Index where variable i is free (2)</span>
            <span class="n">new_ind2</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>

            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">old_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="c1"># Phase 2: Compute optimal depths bottom-up</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)):</span>
        <span class="c1"># If subcube is constant (all 0s or all 1s), depth is 0</span>
        <span class="k">if</span> <span class="n">new_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-7</span> <span class="ow">or</span> <span class="n">new_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-7</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try each free variable as the next query</span>
            <span class="n">trits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span> <span class="o">//</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">trits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Variable i is free</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="c1"># Subcube where variable i = 0</span>
                    <span class="n">num</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">dt0</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                    <span class="c1"># Subcube where variable i = 1</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">**</span><span class="n">i</span>
                    <span class="n">dt1</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

                    <span class="c1"># Worst-case depth after querying variable i</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dt0</span><span class="p">,</span> <span class="n">dt1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">candidate</span> <span class="o">&lt;</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>

    <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="decision_tree_depth_uniform_dp">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.decision_tree_depth_uniform_dp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decision_tree_depth_uniform_dp</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute optimal average-case decision tree depth under uniform distribution.</span>

<span class="sd">    This implements Tal&#39;s `calc_decision_tree_DP_uniform` algorithm with</span>
<span class="sd">    NumPy optimizations for better performance on larger inputs.</span>

<span class="sd">    Unlike worst-case depth, this minimizes the expected number of queries</span>
<span class="sd">    when inputs are drawn uniformly at random.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        weights: Optional per-variable query costs (default: all 1s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (average depth, optimal tree if reconstructible)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># Get truth table</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="c1"># Use compact representation: 1 = output 0, 2 = output 1, 3 = mixed</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">truth_table</span><span class="p">)):</span>
        <span class="n">old_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span>

    <span class="c1"># Build cube indicators</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">new_layer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">first</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)):</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>
                <span class="n">old_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">+</span> <span class="n">index</span>

                <span class="n">new_ind1</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>
                <span class="n">new_ind2</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>

                <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span>
                <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span>

        <span class="n">old_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="c1"># Compute optimal average depths</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">INF</span><span class="p">)</span>
    <span class="n">back_ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Pre-compute trit decompositions for efficiency</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)):</span>
        <span class="c1"># If subcube is constant, cost is 0</span>
        <span class="k">if</span> <span class="n">new_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span> <span class="o">//</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="n">cnt2</span> <span class="o">=</span> <span class="n">trits</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Number of free variables</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">trits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">dt0</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">)]</span>
                    <span class="n">dt1</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">)]</span>
                    <span class="c1"># Cost is sum of subtree costs plus query cost scaled by subcube size</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt0</span> <span class="o">+</span> <span class="n">dt1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cnt2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">candidate</span> <span class="o">&lt;</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">back_ptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Average depth = total cost / 2^n</span>
    <span class="n">avg_depth</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span>

    <span class="c1"># Reconstruct tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">reconstruct_tree</span><span class="p">(</span><span class="n">back_ptr</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">back_ptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">truth_table</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">avg_depth</span><span class="p">,</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="decision_tree_depth_weighted_dp">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.decision_tree_depth_weighted_dp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decision_tree_depth_weighted_dp</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute optimal decision tree depth under arbitrary input distribution.</span>

<span class="sd">    This implements Tal&#39;s `calc_decision_tree_DP_with_prob` algorithm which</span>
<span class="sd">    handles non-uniform input distributions. This is useful for analyzing</span>
<span class="sd">    decision tree performance when some inputs are more likely than others.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        probabilities: Probability of each input (length 2^n)</span>
<span class="sd">        weights: Optional per-variable query costs</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (expected depth, optimal tree)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># Get truth table</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Phase 1: Build value averages for each subcube</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="n">truth_table</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">new_layer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_layer</span><span class="p">)):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>

            <span class="n">new_ind1</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>
            <span class="n">new_ind2</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>

            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">old_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="n">value_layer</span> <span class="o">=</span> <span class="n">new_layer</span><span class="p">[:]</span>

    <span class="c1"># Phase 2: Build probability sums for each subcube</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">new_layer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_layer</span><span class="p">)):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>

            <span class="n">new_ind1</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>
            <span class="n">new_ind2</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>

            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">old_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="n">prob_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="c1"># Phase 3: Compute optimal expected depths</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">INF</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_layer</span><span class="p">)</span>
    <span class="n">back_ptr</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_layer</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value_layer</span><span class="p">)):</span>
        <span class="c1"># Constant subcube: expected cost is 0</span>
        <span class="k">if</span> <span class="n">value_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-7</span> <span class="ow">or</span> <span class="n">value_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-7</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span> <span class="o">//</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">trits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Variable i is free</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">prob_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">continue</span>

                    <span class="n">num</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">num</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">dt0</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">prob_layer</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span> <span class="k">if</span> <span class="n">prob_layer</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">**</span><span class="n">i</span>
                    <span class="n">dt1</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">*</span> <span class="n">prob_layer</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span> <span class="k">if</span> <span class="n">prob_layer</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">dt0</span> <span class="o">+</span> <span class="n">dt1</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">candidate</span> <span class="o">&lt;</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">back_ptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">reconstruct_tree</span><span class="p">(</span><span class="n">back_ptr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">back_ptr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">truth_table</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="decision_tree_size_dp">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.decision_tree_size_dp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decision_tree_size_dp</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">optimize_size_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute decision tree optimizing for size (number of leaves).</span>

<span class="sd">    This implements Tal&#39;s `calc_decision_tree_size_DP` which finds trees</span>
<span class="sd">    that minimize the number of leaves, with depth as a tiebreaker.</span>

<span class="sd">    Smaller trees are often preferred for interpretability and can</span>
<span class="sd">    sometimes be converted to smaller Boolean formulas.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        optimize_size_first: If True, minimize size then depth.</span>
<span class="sd">                            If False, minimize depth then size.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (size, depth, optimal tree)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>

    <span class="c1"># Get truth table</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Build cube averages</span>
    <span class="n">old_layer</span> <span class="o">=</span> <span class="n">truth_table</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">new_layer</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_layer</span><span class="p">)):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="mi">1</span>

            <span class="n">new_ind1</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>
            <span class="n">new_ind2</span> <span class="o">=</span> <span class="p">((</span><span class="n">first</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span> <span class="n">last</span>

            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">new_layer</span><span class="p">[</span><span class="n">new_ind2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">old_layer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">old_layer</span> <span class="o">=</span> <span class="n">new_layer</span>

    <span class="c1"># Results: (size, depth, tree)</span>
    <span class="n">INF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
    <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_layer</span><span class="p">)):</span>
        <span class="n">layer_val</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">new_layer</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">layer_val</span> <span class="o">&lt;</span> <span class="mf">1e-7</span><span class="p">:</span>  <span class="c1"># All 0s</span>
            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">layer_val</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-7</span><span class="p">:</span>  <span class="c1"># All 1s</span>
            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span> <span class="o">//</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">trits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">s0</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">dt0</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">**</span><span class="n">i</span>
                    <span class="n">s1</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">dt1</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

                    <span class="n">sz</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="n">s1</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">dt0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">dt1</span><span class="p">)</span>

                    <span class="n">current_size</span><span class="p">,</span> <span class="n">current_depth</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">optimize_size_first</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">current_size</span><span class="p">,</span> <span class="n">current_depth</span><span class="p">):</span>
                            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">current_depth</span><span class="p">,</span> <span class="n">current_size</span><span class="p">):</span>
                            <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

    <span class="n">size</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="reconstruct_tree">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.reconstruct_tree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_tree</span><span class="p">(</span>
    <span class="n">back_ptr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">truth_table</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a decision tree from back pointers.</span>

<span class="sd">    Args:</span>
<span class="sd">        back_ptr: Array of back pointers from DP</span>
<span class="sd">        index: Current index in the cube representation</span>
<span class="sd">        n_vars: Number of variables</span>
<span class="sd">        truth_table: Original truth table</span>

<span class="sd">    Returns:</span>
<span class="sd">        Reconstructed DecisionTree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">back_ptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This is a leaf - determine value from truth table</span>
        <span class="c1"># Decode index to find which inputs are in this subcube</span>
        <span class="n">trits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span> <span class="o">//</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)]</span>

        <span class="c1"># Find any input in this subcube</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">trits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth_table</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">var</span> <span class="o">=</span> <span class="n">back_ptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Find indices for subtrees</span>
    <span class="n">left_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">var</span><span class="p">)</span>  <span class="c1"># var = 0</span>
    <span class="n">right_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">var</span><span class="p">)</span>  <span class="c1"># var = 1</span>

    <span class="n">left_tree</span> <span class="o">=</span> <span class="n">reconstruct_tree</span><span class="p">(</span><span class="n">back_ptr</span><span class="p">,</span> <span class="n">left_index</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">truth_table</span><span class="p">)</span>
    <span class="n">right_tree</span> <span class="o">=</span> <span class="n">reconstruct_tree</span><span class="p">(</span><span class="n">back_ptr</span><span class="p">,</span> <span class="n">right_index</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">truth_table</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">DecisionTree</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left_tree</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right_tree</span><span class="p">)</span></div>



<div class="viewcode-block" id="enumerate_decision_trees">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.enumerate_decision_trees">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">enumerate_decision_trees</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">prune_dominated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumerate all valid decision trees for a Boolean function.</span>

<span class="sd">    This implements Tal&#39;s `all_decision_trees` algorithm with optional</span>
<span class="sd">    pruning of dominated trees (trees that are strictly worse than</span>
<span class="sd">    another tree on all inputs).</span>

<span class="sd">    Warning: The number of trees can be exponential in n!</span>
<span class="sd">    Only use for small functions (n ≤ 6 recommended).</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        prune_dominated: If True, remove dominated trees</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of decision trees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">)))]</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;enumerate_decision_trees is only practical for n ≤ 8, got n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Find influential variables</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
    <span class="n">influential</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Check if variable i affects the function</span>
        <span class="n">is_influential</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">x_flip</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x_flip</span><span class="p">]:</span>
                <span class="n">is_influential</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">is_influential</span><span class="p">:</span>
            <span class="n">influential</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">influential</span><span class="p">:</span>
        <span class="c1"># Constant function</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">truth_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enumerate_recursive</span><span class="p">(</span><span class="n">fixed</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively enumerate trees for subcube defined by fixed.&quot;&quot;&quot;</span>
        <span class="c1"># Check if subcube is constant</span>
        <span class="n">first_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">is_constant</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># Check if x is in this subcube</span>
            <span class="n">in_subcube</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">fvar</span><span class="p">,</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">fixed</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">fvar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fval</span><span class="p">:</span>
                    <span class="n">in_subcube</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">in_subcube</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">first_val</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">first_val</span><span class="p">:</span>
                    <span class="n">is_constant</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">is_constant</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">DecisionTree</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">first_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">first_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># Try each unfixed influential variable</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">influential</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="c1"># Recurse on both subtrees</span>
                <span class="n">fixed_0</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">fixed</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                <span class="n">fixed_1</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">fixed</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

                <span class="n">trees_0</span> <span class="o">=</span> <span class="n">enumerate_recursive</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">)</span>
                <span class="n">trees_1</span> <span class="o">=</span> <span class="n">enumerate_recursive</span><span class="p">(</span><span class="n">fixed_1</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">t0</span> <span class="ow">in</span> <span class="n">trees_0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">trees_1</span><span class="p">:</span>
                        <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DecisionTree</span><span class="p">(</span><span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">t1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">trees</span>

    <span class="n">all_trees</span> <span class="o">=</span> <span class="n">enumerate_recursive</span><span class="p">({})</span>

    <span class="k">if</span> <span class="n">prune_dominated</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_trees</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">all_trees</span> <span class="o">=</span> <span class="n">_prune_dominated_trees</span><span class="p">(</span><span class="n">all_trees</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">influential</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_trees</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_prune_dominated_trees</span><span class="p">(</span>
    <span class="n">trees</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">],</span> <span class="n">n_vars</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">influential</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DecisionTree</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove trees that are dominated by others on all inputs.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trees</span>

    <span class="c1"># Build matrix of query depths</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">influential</span><span class="p">)):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">influential</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">var</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">depths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">tree</span><span class="o">.</span><span class="n">query_depth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>

    <span class="c1"># Keep non-dominated trees</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)):</span>
        <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Check if j dominates i (j is at least as good on all inputs, better on some)</span>
            <span class="n">at_least_as_good</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">depths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)))</span>
            <span class="n">strictly_better</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">depths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">at_least_as_good</span> <span class="ow">and</span> <span class="n">strictly_better</span><span class="p">:</span>
                <span class="n">dominated</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dominated</span><span class="p">:</span>
            <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trees</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">keep</span>


<div class="viewcode-block" id="count_decision_trees">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.count_decision_trees">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">count_decision_trees</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of distinct decision trees (without enumeration).</span>

<span class="sd">    This is faster than enumerate_decision_trees when you only need the count.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>

<span class="sd">    Returns:</span>
<span class="sd">        Number of distinct decision trees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_opt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n_opt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_opt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">n_opt</span>

    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>

    <span class="c1"># Find influential variables</span>
    <span class="n">influential</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)]:</span>
                <span class="n">influential</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">influential</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="c1"># Use DP with memoization on subcube signatures</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_for_subcube</span><span class="p">(</span><span class="n">fixed_tuple</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fixed_tuple</span><span class="p">)</span>

        <span class="c1"># Check if constant</span>
        <span class="n">first_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">is_constant</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">in_subcube</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">fv</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">fv</span> <span class="ow">in</span> <span class="n">fixed</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">in_subcube</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">first_val</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">first_val</span><span class="p">:</span>
                    <span class="n">is_constant</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">is_constant</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># Sum over all choices of root variable</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">influential</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="n">fixed_0</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">fixed_tuple</span><span class="p">)</span> <span class="o">+</span> <span class="p">[(</span><span class="n">var</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]))</span>
                <span class="n">fixed_1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">fixed_tuple</span><span class="p">)</span> <span class="o">+</span> <span class="p">[(</span><span class="n">var</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]))</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">count_for_subcube</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">count_for_subcube</span><span class="p">(</span><span class="n">fixed_1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total</span>

    <span class="k">return</span> <span class="n">count_for_subcube</span><span class="p">(())</span></div>



<div class="viewcode-block" id="randomized_complexity_matrix">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.randomized_complexity_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">randomized_complexity_matrix</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">output_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the game matrix for randomized decision tree complexity.</span>

<span class="sd">    The rows correspond to inputs, columns to decision trees.</span>
<span class="sd">    Entry (i, j) is the number of queries tree j makes on input i.</span>

<span class="sd">    By the minimax theorem, the randomized complexity R(f) equals</span>
<span class="sd">    the value of this matrix game.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        output_value: If specified, only include inputs where f(x) = output_value</span>

<span class="sd">    Returns:</span>
<span class="sd">        NumPy matrix where M[i,j] = depth of tree j on input i</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function must have defined n_vars&quot;</span><span class="p">)</span>

    <span class="n">trees</span> <span class="o">=</span> <span class="n">enumerate_decision_trees</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">truth_table</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>

    <span class="c1"># Select inputs</span>
    <span class="k">if</span> <span class="n">output_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">truth_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">output_value</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">))</span>

    <span class="c1"># Build matrix</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trees</span><span class="p">):</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_depth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">matrix</span></div>



<div class="viewcode-block" id="compute_randomized_complexity">
<a class="viewcode-back" href="../../../api/boofun.analysis.decision_trees.html#boofun.analysis.decision_trees.compute_randomized_complexity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_randomized_complexity</span><span class="p">(</span>
    <span class="n">f</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">,</span> <span class="n">output_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the randomized decision tree complexity R(f).</span>

<span class="sd">    This solves the minimax game between:</span>
<span class="sd">    - The algorithm (chooses a distribution over decision trees)</span>
<span class="sd">    - The adversary (chooses an input)</span>

<span class="sd">    R(f) = min over tree distributions, max over inputs, E[queries]</span>

<span class="sd">    By von Neumann&#39;s minimax theorem, this equals:</span>
<span class="sd">    R(f) = max over input distributions, min over trees, E[queries]</span>

<span class="sd">    Requires scipy for linear programming.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: BooleanFunction to analyze</span>
<span class="sd">        output_value: If specified, compute R_b(f) for inputs with f(x)=b</span>

<span class="sd">    Returns:</span>
<span class="sd">        Randomized query complexity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">linprog</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;scipy is required for compute_randomized_complexity&quot;</span><span class="p">)</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">randomized_complexity_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">output_value</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n_trees</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n_trees</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="c1"># Solve LP: max v s.t. Ax &gt;= v*1, sum(x) = 1, x &gt;= 0</span>
    <span class="c1"># This finds the optimal mixed strategy for the row player (adversary)</span>
    <span class="c1"># Equivalently: min c&#39;x s.t. A&#39;x &lt;= b, x &gt;= 0</span>

    <span class="c1"># Variables: [p_1, ..., p_n, v] where p_i is prob of tree i, v is value</span>
    <span class="c1"># Maximize v subject to:</span>
    <span class="c1">#   For each input i: sum_j p_j * M[i,j] &gt;= v</span>
    <span class="c1">#   sum_j p_j = 1</span>
    <span class="c1">#   p_j &gt;= 0</span>

    <span class="c1"># Convert to minimization: minimize -v</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_trees</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Minimize -v (maximize v)</span>

    <span class="c1"># Inequality constraints: v - sum_j p_j * M[i,j] &lt;= 0</span>
    <span class="n">A_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n_trees</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">A_ub</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">matrix</span>  <span class="c1"># -M</span>
    <span class="n">A_ub</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># v</span>
    <span class="n">b_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="c1"># Equality constraint: sum_j p_j = 1</span>
    <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_trees</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">A_eq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>

    <span class="c1"># Bounds: p_j &gt;= 0, v unbounded</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n_trees</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span>  <span class="c1"># Negate because we minimized -v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fallback: return deterministic complexity</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024-2026, Gabriel Taboada.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>