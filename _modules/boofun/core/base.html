

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boofun.core.base &mdash; BooFun 1.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6efca38a"></script>
      <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BooFun
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guides:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/spectral_analysis.html">Spectral Analysis Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/query_complexity.html">Query Complexity Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/hypercontractivity.html">Hypercontractivity Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/cryptographic.html">Cryptographic Analysis Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/learning.html">Learning Theory Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/representations.html">Representations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/operations.html">Function Operations Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/families.html">Function Families and Growth Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/probabilistic.html">Probabilistic View &amp; Pseudorandomness</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/advanced.html">Advanced Topics Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/migration_from_tal.html">Migration from Talâ€™s BooleanFunc.py</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../comparison_guide.html">Library Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance.html">Performance Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../error_handling.html">Error Handling in BooFun</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cross_validation.html">Cross-Validation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING.html">Contributing to BooFun</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../STYLE_GUIDE.html">BooFun Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../TEST_GUIDELINES.html">Test Guidelines</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/boofun.html">boofun</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BooFun</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../boofun.html">boofun</a></li>
      <li class="breadcrumb-item active">boofun.core.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boofun.core.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Protocol</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..utils.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConversionError</span><span class="p">,</span> <span class="n">EvaluationError</span><span class="p">,</span> <span class="n">InvalidInputError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.conversion_graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_conversion_path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.errormodels</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExactErrorModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.factory</span><span class="w"> </span><span class="kn">import</span> <span class="n">BooleanFunctionFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.representations.registry</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_strategy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.spaces</span><span class="w"> </span><span class="kn">import</span> <span class="n">Space</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.query_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">AccessType</span><span class="p">,</span> <span class="n">QueryModel</span>

<span class="c1"># Check Numba availability (optional optimization)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span>  <span class="c1"># noqa: F401</span>

    <span class="n">USE_NUMBA</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">USE_NUMBA</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Only warn once at import time, not on every operation</span>
    <span class="c1"># Using UserWarning instead of ImportWarning to avoid pytest treating it as error</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;Numba not installed - using pure Python mode. &quot;</span>
        <span class="s2">&quot;Install numba for 10-100x faster computations: pip install numba&quot;</span><span class="p">,</span>
        <span class="ne">UserWarning</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="Property">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Property">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Property</span><span class="p">:</span>
<div class="viewcode-block" id="Property.__init__">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Property.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">test_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closed_under</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_func</span> <span class="o">=</span> <span class="n">test_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_under</span> <span class="o">=</span> <span class="n">closed_under</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="PropertyStore">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.PropertyStore">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PropertyStore</span><span class="p">:</span>
<div class="viewcode-block" id="PropertyStore.__init__">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.PropertyStore.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="PropertyStore.add">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.PropertyStore.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">:</span> <span class="n">Property</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;property&quot;</span><span class="p">:</span> <span class="n">prop</span><span class="p">,</span> <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">}</span></div>


<div class="viewcode-block" id="PropertyStore.has">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.PropertyStore.has">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span></div>
</div>



<div class="viewcode-block" id="Evaluable">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Evaluable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Evaluable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<div class="viewcode-block" id="Evaluable.evaluate">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Evaluable.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span> <span class="o">...</span></div>
</div>



<div class="viewcode-block" id="Representable">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Representable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Representable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<div class="viewcode-block" id="Representable.to_representation">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.Representable.to_representation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="o">...</span></div>
</div>



<div class="viewcode-block" id="BooleanFunction">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BooleanFunction</span><span class="p">(</span><span class="n">Evaluable</span><span class="p">,</span> <span class="n">Representable</span><span class="p">):</span>
<div class="viewcode-block" id="BooleanFunction.__init__">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">space</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;plus_minus_cube&quot;</span><span class="p">,</span>
        <span class="n">error_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">storage_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_space</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">PropertyStore</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_model</span> <span class="o">=</span> <span class="n">error_model</span> <span class="ow">or</span> <span class="n">ExactErrorModel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracking</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tracking&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restrictions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;restrictions&quot;</span><span class="p">)</span>
        <span class="c1"># Use explicit None check to handle n=0 (constant functions) correctly</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_vars&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nickname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nickname&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;x_0&quot;</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;n_vars as int. Returns 0 if not set (for adapted/partial functions).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the truth table as a NumPy array for NumPy compatibility.</span>

<span class="sd">        Note: The &#39;copy&#39; parameter is for NumPy 2.0 compatibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">truth_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">truth_table</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Addition operator - creates composite function with + operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subtraction operator - creates composite function with - operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multiplication operator - creates composite function with * operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bitwise AND operator - creates composite function with &amp; operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&amp;&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bitwise OR operator - creates composite function with | operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bitwise XOR operator - creates composite function with ^ operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bitwise NOT operator - creates composite function with ~ operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;~&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Power operator - creates composite function with ** operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">create_composite</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;**&quot;</span><span class="p">,</span>
            <span class="n">left_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">right_func</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>  <span class="c1"># Pass exponent as right_func for consistency</span>
        <span class="p">)</span>

<div class="viewcode-block" id="BooleanFunction.compose">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.compose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compose this function with another BooleanFunction.</span>

<span class="sd">        Semantics mirror the legacy ``BooleanFunc.compose``: if ``self`` depends</span>
<span class="sd">        on ``n`` variables and ``other`` depends on ``m`` variables, the result is</span>
<span class="sd">        a function on ``n * m`` variables obtained by substituting ``other`` into</span>
<span class="sd">        each input of ``self`` on disjoint variable blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">compose_truth_tables</span><span class="p">(</span>
            <span class="n">boolean_function_cls</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">outer_func</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">inner_func</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Two BooleanFunctions are equal if they have the same truth table.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BooleanFunction</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">n_vars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tt_self</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="n">tt_other</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">tt_self</span> <span class="o">==</span> <span class="n">tt_other</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash based on truth table content.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">,</span> <span class="n">tt</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nickname&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;x_0&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> (n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BooleanFunction(n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nickname&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">tt_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">tt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">tt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, ..., </span><span class="si">{</span><span class="n">tt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">] (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="si">}</span><span class="s2"> entries)&quot;</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">tt_str</span> <span class="o">=</span> <span class="s2">&quot;oracle&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; &#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;x_0&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BooleanFunction(</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, tt=</span><span class="si">{</span><span class="n">tt_str</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space_type</span><span class="p">):</span>
        <span class="c1"># Handle both string and Space enum inputs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space_type</span><span class="p">,</span> <span class="n">Space</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">space_type</span>
        <span class="k">elif</span> <span class="n">space_type</span> <span class="o">==</span> <span class="s2">&quot;boolean_cube&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Space</span><span class="o">.</span><span class="n">BOOLEAN_CUBE</span>
        <span class="k">elif</span> <span class="n">space_type</span> <span class="o">==</span> <span class="s2">&quot;plus_minus_cube&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Space</span><span class="o">.</span><span class="n">PLUS_MINUS_CUBE</span>
        <span class="k">elif</span> <span class="n">space_type</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Space</span><span class="o">.</span><span class="n">REAL</span>
        <span class="k">elif</span> <span class="n">space_type</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Space</span><span class="o">.</span><span class="n">LOG</span>
        <span class="k">elif</span> <span class="n">space_type</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Space</span><span class="o">.</span><span class="n">GAUSSIAN</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown space type: </span><span class="si">{</span><span class="n">space_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute representation using intelligent conversion graph.</span>

<span class="sd">        Uses Dijkstra&#39;s algorithm to find optimal conversion path from</span>
<span class="sd">        available representations to target representation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ConversionError: If no conversion path exists or conversion fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rep_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConversionError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot compute representation: Boolean function has no representations&quot;</span><span class="p">,</span>
                <span class="n">target_repr</span><span class="o">=</span><span class="n">rep_type</span><span class="p">,</span>
                <span class="n">suggestion</span><span class="o">=</span><span class="s2">&quot;Add a representation first using add_representation() or create()&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Find the best source representation using conversion graph</span>
        <span class="n">best_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_source_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">available_reps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">source_rep_type</span><span class="p">,</span> <span class="n">source_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">find_conversion_path</span><span class="p">(</span><span class="n">source_rep_type</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">and</span> <span class="p">(</span><span class="n">best_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">path</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">&lt;</span> <span class="n">best_path</span><span class="o">.</span><span class="n">total_cost</span><span class="p">):</span>  <span class="c1"># type: ignore[unreachable]</span>
                <span class="n">best_path</span> <span class="o">=</span> <span class="n">path</span>
                <span class="n">best_source_data</span> <span class="o">=</span> <span class="n">source_data</span>

        <span class="k">if</span> <span class="n">best_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Fallback to direct conversion from first available representation</span>
            <span class="n">source_rep_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">[</span><span class="n">source_rep_type</span><span class="p">]</span>
            <span class="n">source_strategy</span> <span class="o">=</span> <span class="n">get_strategy</span><span class="p">(</span><span class="n">source_rep_type</span><span class="p">)</span>
            <span class="n">target_strategy</span> <span class="o">=</span> <span class="n">get_strategy</span><span class="p">(</span><span class="n">rep_type</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">source_strategy</span><span class="o">.</span><span class="n">convert_to</span><span class="p">(</span><span class="n">target_strategy</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConversionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No conversion path available from &#39;</span><span class="si">{</span><span class="n">source_rep_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">rep_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="n">source_repr</span><span class="o">=</span><span class="n">source_rep_type</span><span class="p">,</span>
                    <span class="n">target_repr</span><span class="o">=</span><span class="n">rep_type</span><span class="p">,</span>
                    <span class="n">context</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;available_representations&quot;</span><span class="p">:</span> <span class="n">available_reps</span><span class="p">},</span>
                    <span class="n">suggestion</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Available representations: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">available_reps</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConversionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Conversion from &#39;</span><span class="si">{</span><span class="n">source_rep_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">rep_type</span><span class="si">}</span><span class="s2">&#39; failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">source_repr</span><span class="o">=</span><span class="n">source_rep_type</span><span class="p">,</span>
                    <span class="n">target_repr</span><span class="o">=</span><span class="n">rep_type</span><span class="p">,</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use optimal path from conversion graph</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">best_path</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">best_source_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConversionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Conversion to &#39;</span><span class="si">{</span><span class="n">rep_type</span><span class="si">}</span><span class="s2">&#39; failed during path execution: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">target_repr</span><span class="o">=</span><span class="n">rep_type</span><span class="p">,</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_representation</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="BooleanFunction.get_representation">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.get_representation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve or compute representation&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_representation</span><span class="p">(</span><span class="n">rep_type</span><span class="p">)</span>
        <span class="n">rep_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">[</span><span class="n">rep_type</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rep_data</span></div>


<div class="viewcode-block" id="BooleanFunction.add_representation">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.add_representation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a representation to this boolean function&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rep_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factory</span> <span class="o">=</span> <span class="n">BooleanFunctionFactory</span><span class="p">()</span>
            <span class="n">rep_type</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">_determine_rep_type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">[</span><span class="n">rep_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="BooleanFunction.evaluate">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate function with automatic input type detection and representation selection.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: Input data (array, list, or scipy random variable)</span>
<span class="sd">            rep_type: Optional specific representation to use</span>
<span class="sd">            **kwargs: Additional evaluation parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean result(s) or distribution (with error model applied)</span>

<span class="sd">        Raises:</span>
<span class="sd">            InvalidInputError: If inputs are empty or have unsupported type</span>
<span class="sd">            EvaluationError: If evaluation fails</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bit_strings</span> <span class="o">=</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bit_strings&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bit_strings</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_index</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># Get base result</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;rvs&quot;</span><span class="p">):</span>  <span class="c1"># scipy.stats random variable</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_stochastic</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="n">rep_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="c1"># Convert tuple to list for consistent processing</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="c1"># Check for empty inputs (only for lists and multi-dimensional arrays)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot evaluate empty input list&quot;</span><span class="p">,</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="s2">&quot;inputs&quot;</span><span class="p">,</span>
                    <span class="n">received</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">expected</span><span class="o">=</span><span class="s2">&quot;non-empty list of inputs&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">inputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">inputs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot evaluate empty input array&quot;</span><span class="p">,</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="s2">&quot;inputs&quot;</span><span class="p">,</span>
                    <span class="n">received</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;empty array with shape </span><span class="si">{</span><span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">expected</span><span class="o">=</span><span class="s2">&quot;non-empty array&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Convert single values to array for consistent processing</span>
            <span class="n">is_scalar_input</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">is_scalar_input</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inputs</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_deterministic</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="n">rep_type</span><span class="p">)</span>
            <span class="c1"># Return scalar if input was scalar</span>
            <span class="k">if</span> <span class="n">is_scalar_input</span><span class="p">:</span>
                <span class="c1"># Handle case where result is already a scalar</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
                    <span class="k">pass</span>  <span class="c1"># Already scalar</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported input type for evaluation&quot;</span><span class="p">,</span>
                <span class="n">parameter</span><span class="o">=</span><span class="s2">&quot;inputs&quot;</span><span class="p">,</span>
                <span class="n">received</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">expected</span><span class="o">=</span><span class="s2">&quot;list, tuple, np.ndarray, int, float, or scipy random variable&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Apply error model if not exact</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_model</span><span class="p">,</span> <span class="s2">&quot;apply_error&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_model</span><span class="o">.</span><span class="n">apply_error</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Only warn if error model was explicitly configured (not default ExactErrorModel)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_model</span><span class="p">,</span> <span class="n">ExactErrorModel</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error model </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_model</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Using unadjusted result.&quot;</span><span class="p">,</span>
                        <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert boolean vector to integer index.</span>

<span class="sd">        Uses positional summation instead of np.packbits, which only</span>
<span class="sd">        handles 8 bits. This works correctly for any n.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bits</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate using the specified or first available representation.</span>

<span class="sd">        Automatically uses batch processing for large input arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rep_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rep_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">))</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">[</span><span class="n">rep_type</span><span class="p">]</span>

        <span class="c1"># Use batch processing for large arrays</span>
        <span class="k">if</span> <span class="n">inputs</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>  <span class="c1"># Threshold for batch processing</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.batch_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_batch</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">process_batch</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="c1"># Batch processing not available, use standard path</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Log the fallback so users know about potential performance impact</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Batch processing failed (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;falling back to sequential evaluation. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;This may be slower for large inputs.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Standard evaluation for small inputs or fallback</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">get_strategy</span><span class="p">(</span><span class="n">rep_type</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_probabilistic_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configure as scipy.stats-like random variable&quot;&quot;&quot;</span>
        <span class="c1"># Add methods that make this behave like rv_discrete/rv_continuous</span>
        <span class="c1"># self._configure_sampling_methods()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rv_inputs</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle random variable inputs using Monte Carlo.&quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">rv_inputs</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_deterministic</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

<div class="viewcode-block" id="BooleanFunction.evaluate_range">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.evaluate_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BooleanFunction.rvs">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.rvs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random samples (like scipy.stats)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;distribution&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="c1"># Fallback: uniform sampling from truth table</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_sample</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_uniform_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate uniform random samples from the function&#39;s domain.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

        <span class="c1"># Generate random inputs and evaluate</span>
        <span class="n">domain_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="n">random_indices</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">domain_size</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Evaluate function at random points</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">random_indices</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span> <span class="k">else</span> <span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="BooleanFunction.pmf">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.pmf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Probability mass function&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pmf_cache&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pmf_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_pmf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute probability mass function for input x.&quot;&quot;&quot;</span>
        <span class="c1"># For Boolean functions, PMF is just the function value</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<div class="viewcode-block" id="BooleanFunction.cdf">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.cdf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cumulative distribution function&quot;&quot;&quot;</span></div>

        <span class="c1"># return self._compute_cdf(x)</span>

    <span class="c1"># get methods</span>
<div class="viewcode-block" id="BooleanFunction.get_n_vars">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.get_n_vars">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_n_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span></div>


    <span class="c1"># Backwards-compatible property aliases</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for n_vars for backwards compatibility.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for n_vars for backwards compatibility.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="c1"># get methods</span>
<div class="viewcode-block" id="BooleanFunction.has_rep">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.has_rep">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rep_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BooleanFunction.get_conversion_options">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.get_conversion_options">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_conversion_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get available conversion options from current representations.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_cost: Maximum acceptable conversion cost</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with conversion options and costs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.conversion_graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_conversion_options</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="n">all_options</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source_rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">get_conversion_options</span><span class="p">(</span><span class="n">source_rep</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_options</span> <span class="ow">or</span> <span class="n">path</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">&lt;</span> <span class="n">all_options</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s2">&quot;cost&quot;</span><span class="p">]:</span>
                    <span class="n">all_options</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;cost&quot;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">total_cost</span><span class="p">,</span>
                        <span class="s2">&quot;path&quot;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
                        <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">source_rep</span><span class="p">,</span>
                        <span class="s2">&quot;exact&quot;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">total_cost</span><span class="o">.</span><span class="n">is_exact</span><span class="p">,</span>
                    <span class="p">}</span>

        <span class="k">return</span> <span class="n">all_options</span></div>


<div class="viewcode-block" id="BooleanFunction.estimate_conversion_cost">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.estimate_conversion_cost">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_conversion_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_rep</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate cost to convert to target representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_rep: Target representation name</span>

<span class="sd">        Returns:</span>
<span class="sd">            Conversion cost estimate or None if impossible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.conversion_graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">estimate_conversion_cost</span>

        <span class="k">if</span> <span class="n">target_rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Already available</span>

        <span class="n">best_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">source_rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">estimate_conversion_cost</span><span class="p">(</span><span class="n">source_rep</span><span class="p">,</span> <span class="n">target_rep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="ow">and</span> <span class="p">(</span><span class="n">best_cost</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">best_cost</span><span class="p">):</span>  <span class="c1"># type: ignore[unreachable]</span>
                <span class="n">best_cost</span> <span class="o">=</span> <span class="n">cost</span>

        <span class="k">return</span> <span class="n">best_cost</span></div>


<div class="viewcode-block" id="BooleanFunction.to">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">representation_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to specified representation (convenience method).</span>

<span class="sd">        Args:</span>
<span class="sd">            representation_type: Target representation type</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self (for method chaining)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="n">representation_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="c1"># =========================================================================</span>
    <span class="c1"># Restriction Operations (ported from legacy BooleanFunc)</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.fix">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.fix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix variable(s) to specific value(s), returning a new function on fewer variables.</span>

<span class="sd">        This is a fundamental operation for Boolean function analysis, used in:</span>
<span class="sd">        - Decision tree computation</span>
<span class="sd">        - Certificate analysis</span>
<span class="sd">        - Influence computation via derivatives</span>

<span class="sd">        Args:</span>
<span class="sd">            var: Variable index (int) or list of variable indices</span>
<span class="sd">            val: Value (0 or 1) or list of values to fix variables to</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction with fixed variables removed</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.create([0, 1, 1, 0])  # XOR on 2 vars</span>
<span class="sd">            &gt;&gt;&gt; g = f.fix(0, 1)  # Fix x_0 = 1, get function on x_1 only</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_multi</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_single</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix a single variable to a specific value.</span>

<span class="sd">        Args:</span>
<span class="sd">            var: Variable index (0-indexed from MSB)</span>
<span class="sd">            val: Value to fix (0 or 1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction with one fewer variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value must be 0 or 1, got </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable index </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> out of range [0, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="n">new_n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">new_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case: fixing last variable gives constant function</span>
            <span class="n">truth_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
            <span class="n">result_val</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">truth_table</span><span class="p">[</span><span class="n">val</span><span class="p">])</span>
            <span class="n">new_tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">result_val</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build new truth table by selecting entries where var has value val</span>
            <span class="n">old_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
            <span class="n">new_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">new_n</span>
            <span class="n">new_tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_size</span><span class="p">):</span>
                <span class="c1"># Insert the fixed bit at position var</span>
                <span class="c1"># Bits to the left of var stay in place</span>
                <span class="c1"># Bits at and to the right of var shift right by 1</span>
                <span class="n">left_mask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">var</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">right_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">var</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">left_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">left_mask</span>
                <span class="n">right_bits</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="n">right_mask</span>
                <span class="n">fixed_bit</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">var</span>

                <span class="n">old_idx</span> <span class="o">=</span> <span class="n">left_bits</span> <span class="o">|</span> <span class="n">fixed_bit</span> <span class="o">|</span> <span class="n">right_bits</span>
                <span class="n">new_tt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">new_n</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix multiple variables to specific values.</span>

<span class="sd">        Args:</span>
<span class="sd">            vars: List of variable indices</span>
<span class="sd">            vals: List of values (0 or 1) to fix each variable to</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction with len(vars) fewer variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vars and vals must have same length&quot;</span><span class="p">)</span>

        <span class="c1"># Sort by variable index descending to fix from right to left</span>
        <span class="c1"># This ensures indices stay valid as we remove variables</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">vals</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_fix_single</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="BooleanFunction.restrict">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.restrict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">restrict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alias for fix() - restrict a variable to a specific value.</span>

<span class="sd">        This terminology is often used in the literature (e.g., random restrictions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.derivative">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the discrete derivative with respect to variable var.</span>

<span class="sd">        The derivative D_i f is defined as:</span>
<span class="sd">            D_i f(x) = f(x) XOR f(x âŠ• e_i)</span>

<span class="sd">        where e_i is the i-th unit vector. The derivative is 1 exactly when</span>
<span class="sd">        variable i is influential at input x.</span>

<span class="sd">        Args:</span>
<span class="sd">            var: Variable index to differentiate with respect to</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction representing the derivative</span>

<span class="sd">        Note:</span>
<span class="sd">            The influence of variable i equals E[D_i f] = Pr[D_i f(x) = 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable index </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> out of range [0, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>
        <span class="n">old_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># Flip bit at position var (LSB=xâ‚€ convention)</span>
            <span class="n">x_flipped</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">var</span><span class="p">)</span>
            <span class="n">new_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">x_flipped</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.shift">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the function: f_s(x) = f(x âŠ• s).</span>

<span class="sd">        This applies an XOR mask to all inputs, effectively translating</span>
<span class="sd">        the function in the Boolean cube.</span>

<span class="sd">        Args:</span>
<span class="sd">            s: Shift mask (integer representing the XOR offset)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction with shifted inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shift </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> out of range [0, </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>
        <span class="n">old_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">new_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">x</span> <span class="o">^</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.negation">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.negation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">negation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the negation of this function: NOT f.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New BooleanFunction where all outputs are flipped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="o">~</span><span class="n">old_tt</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.bias">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.bias">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bias</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the bias of the function: E[(-1)^f(x)] = 1 - 2*Pr[f(x)=1].</span>

<span class="sd">        The bias is in [-1, 1]:</span>
<span class="sd">        - bias = 1 means f is constantly 0</span>
<span class="sd">        - bias = -1 means f is constantly 1</span>
<span class="sd">        - bias = 0 means f is balanced</span>

<span class="sd">        Returns:</span>
<span class="sd">            Bias value in [-1, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ones_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ones_count</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_balanced">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_balanced">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the function is balanced (equal 0s and 1s in truth table).</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if the function outputs 0 and 1 equally often</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ones_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ones_count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span></div>


    <span class="c1"># =========================================================================</span>
    <span class="c1"># Query Model (for production safety)</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.query_model">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.query_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">query_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_queries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10_000_000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the query model for this function.</span>

<span class="sd">        The query model helps understand computational costs and prevents</span>
<span class="sd">        accidentally running exponential-time operations on huge functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_queries: Maximum acceptable number of function evaluations</span>

<span class="sd">        Returns:</span>
<span class="sd">            QueryModel instance with cost estimation methods</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.create(huge_neural_net, n=100)</span>
<span class="sd">            &gt;&gt;&gt; qm = f.query_model()</span>
<span class="sd">            &gt;&gt;&gt; qm.can_compute(&quot;is_linear&quot;)  # True - O(k) queries</span>
<span class="sd">            &gt;&gt;&gt; qm.can_compute(&quot;fourier&quot;)     # False - would need 2^100 queries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.query_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">QueryModel</span>

        <span class="k">return</span> <span class="n">QueryModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_queries</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.access_type">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.access_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">access_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AccessType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the access type for this function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            AccessType.EXPLICIT if we have the full truth table</span>
<span class="sd">            AccessType.QUERY if we can only evaluate on demand</span>
<span class="sd">            AccessType.SYMBOLIC if we have a formula</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.query_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_access_type</span>

        <span class="k">return</span> <span class="n">get_access_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_explicit">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_explicit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if we have explicit access (full truth table).&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.query_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">AccessType</span><span class="p">,</span> <span class="n">get_access_type</span>

        <span class="k">return</span> <span class="n">get_access_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">AccessType</span><span class="o">.</span><span class="n">EXPLICIT</span></div>


<div class="viewcode-block" id="BooleanFunction.is_query_access">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_query_access">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_query_access</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if this is a query-access function (no truth table).&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.query_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">AccessType</span><span class="p">,</span> <span class="n">get_access_type</span>

        <span class="k">return</span> <span class="n">get_access_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">AccessType</span><span class="o">.</span><span class="n">QUERY</span></div>


    <span class="c1"># =========================================================================</span>
    <span class="c1"># Spectral Analysis Methods (mathematician-friendly API)</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.fourier">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.fourier">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fourier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Fourier coefficients fÌ‚(S) for all subsets S âŠ† [n].</span>

<span class="sd">        The Fourier expansion is: f(x) = Î£_S fÌ‚(S) Ï‡_S(x)</span>
<span class="sd">        where Ï‡_S(x) = âˆ_{iâˆˆS} x_i are the Walsh characters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of Fourier coefficients indexed by subset bitmask</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; xor = bf.create([0, 1, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; coeffs = xor.fourier()</span>
<span class="sd">            &gt;&gt;&gt; coeffs[3]  # fÌ‚({0,1}) = -1 for XOR</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralAnalyzer</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpectralAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">fourier_expansion</span><span class="p">(</span><span class="n">force_recompute</span><span class="o">=</span><span class="n">force_recompute</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.spectrum">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.spectrum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for fourier() - returns Fourier spectrum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">(</span><span class="n">force_recompute</span><span class="o">=</span><span class="n">force_recompute</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.degree">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gf2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the degree of the function.</span>

<span class="sd">        Args:</span>
<span class="sd">            gf2: If True, compute GF(2) (algebraic) degree</span>
<span class="sd">                 If False, compute Fourier (real) degree</span>

<span class="sd">        Returns:</span>
<span class="sd">            Maximum degree of non-zero coefficient</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; xor = bf.create([0, 1, 1, 0])</span>
<span class="sd">            &gt;&gt;&gt; xor.degree()        # Fourier degree = 2</span>
<span class="sd">            &gt;&gt;&gt; xor.degree(gf2=True)  # GF(2) degree = 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gf2</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.gf2</span><span class="w"> </span><span class="kn">import</span> <span class="n">gf2_degree</span>

            <span class="k">return</span> <span class="n">gf2_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.fourier</span><span class="w"> </span><span class="kn">import</span> <span class="n">fourier_degree</span>

            <span class="k">return</span> <span class="n">fourier_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.influences">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.influences">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">influences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_recompute</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute influences of all variables: Inf_i[f] = Pr[f(x) â‰  f(x âŠ• e_i)].</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of influences, one per variable</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; maj = bf.majority(3)</span>
<span class="sd">            &gt;&gt;&gt; maj.influences()  # All equal for symmetric function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralAnalyzer</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpectralAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">influences</span><span class="p">(</span><span class="n">force_recompute</span><span class="o">=</span><span class="n">force_recompute</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.influence">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.influence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">influence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute influence of a single variable.</span>

<span class="sd">        Args:</span>
<span class="sd">            var: Variable index (0-indexed)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Influence value in [0, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influences</span><span class="p">()[</span><span class="n">var</span><span class="p">])</span></div>


<div class="viewcode-block" id="BooleanFunction.total_influence">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.total_influence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_influence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute total influence: I[f] = Î£_i Inf_i[f].</span>

<span class="sd">        Also called average sensitivity.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sum of all variable influences</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralAnalyzer</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpectralAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">total_influence</span><span class="p">()</span></div>


<div class="viewcode-block" id="BooleanFunction.noise_stability">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.noise_stability">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">noise_stability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute noise stability at correlation Ï.</span>

<span class="sd">        Stab_Ï[f] = E[f(x)f(y)] where y is Ï-correlated with x.</span>
<span class="sd">        In Fourier: Stab_Ï[f] = Î£_S fÌ‚(S)Â² Ï^|S|</span>

<span class="sd">        Args:</span>
<span class="sd">            rho: Correlation parameter in [-1, 1]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Noise stability value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralAnalyzer</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpectralAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">noise_stability</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.W">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.W">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">W</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Fourier weight at exactly degree k: W^{=k}[f] = Î£_{|S|=k} fÌ‚(S)Â².</span>

<span class="sd">        Args:</span>
<span class="sd">            k: Degree level</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sum of squared Fourier coefficients at degree k</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">()</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">bin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">total</span></div>


<div class="viewcode-block" id="BooleanFunction.W_leq">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.W_leq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">W_leq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Fourier weight up to degree k: W^{â‰¤k}[f] = Î£_{|S|â‰¤k} fÌ‚(S)Â².</span>

<span class="sd">        This measures spectral concentration on low-degree coefficients.</span>

<span class="sd">        Args:</span>
<span class="sd">            k: Maximum degree</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sum of squared Fourier coefficients up to degree k</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralAnalyzer</span>

        <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpectralAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">spectral_concentration</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.sparsity">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.sparsity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count non-zero Fourier coefficients.</span>

<span class="sd">        From O&#39;Donnell: degree-k functions have at most 4^k non-zero coefficients.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold: Minimum magnitude to count as non-zero</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of significant Fourier coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.fourier</span><span class="w"> </span><span class="kn">import</span> <span class="n">fourier_sparsity</span>

        <span class="k">return</span> <span class="n">fourier_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.spectral_weight_by_degree">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.spectral_weight_by_degree">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spectral_weight_by_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spectral weight at each degree level.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict mapping degree k -&gt; W^{=k}[f] = Î£_{|S|=k} fÌ‚(S)Â²</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; maj = bf.majority(5)</span>
<span class="sd">            &gt;&gt;&gt; maj.spectral_weight_by_degree()</span>
<span class="sd">            {0: 0.0, 1: 0.625, 3: 0.3125, 5: 0.0625}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">()</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span></div>


<div class="viewcode-block" id="BooleanFunction.heavy_coefficients">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.heavy_coefficients">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">heavy_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find Fourier coefficients with |fÌ‚(S)| â‰¥ Ï„.</span>

<span class="sd">        Args:</span>
<span class="sd">            tau: Threshold for &quot;heavy&quot; coefficient</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of (subset_tuple, coefficient) pairs sorted by magnitude</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; maj = bf.majority(3)</span>
<span class="sd">            &gt;&gt;&gt; maj.heavy_coefficients(0.3)</span>
<span class="sd">            [((0,), 0.5), ((1,), 0.5), ((2,), 0.5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">()</span>
        <span class="n">heavy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">:</span>
                <span class="c1"># Convert bitmask to tuple of variable indices</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">heavy</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">subset</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">heavy</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>


<div class="viewcode-block" id="BooleanFunction.variance">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.variance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">variance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute variance: Var[f] = E[fÂ²] - E[f]Â² = Î£_{Sâ‰ âˆ…} fÌ‚(S)Â².</span>

<span class="sd">        Returns:</span>
<span class="sd">            Variance of the function (0 for constant, 1 for balanced Â±1 function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Skip S=âˆ…</span></div>


<div class="viewcode-block" id="BooleanFunction.max_influence">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.max_influence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_influence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute maximum influence: max_i Inf_i[f].</span>

<span class="sd">        Important for KKL theorem: max_i Inf_i[f] â‰¥ Î©(log n / n) for balanced f.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Maximum influence value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influences</span><span class="p">())</span></div>


<div class="viewcode-block" id="BooleanFunction.analyze">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.analyze">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quick analysis returning common metrics.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict with: n_vars, is_balanced, variance, degree,</span>
<span class="sd">                       total_influence, max_influence, noise_stability_0.5</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bf.majority(5).analyze()</span>
<span class="sd">            {&#39;n_vars&#39;: 5, &#39;is_balanced&#39;: True, &#39;variance&#39;: 1.0, ...}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;n_vars&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">,</span>
            <span class="s2">&quot;is_balanced&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_balanced</span><span class="p">(),</span>
            <span class="s2">&quot;variance&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance</span><span class="p">(),</span>
            <span class="s2">&quot;degree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span>
            <span class="s2">&quot;total_influence&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_influence</span><span class="p">(),</span>
            <span class="s2">&quot;max_influence&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_influence</span><span class="p">(),</span>
            <span class="s2">&quot;noise_stability_0.5&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_stability</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="BooleanFunction.negate_inputs">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.negate_inputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">negate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute g(x) = f(-x) where -x flips all bits.</span>

<span class="sd">        In Fourier: Ä(S) = (-1)^|S| fÌ‚(S) (odd-degree coefficients flip sign)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New function with negated inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.fourier</span><span class="w"> </span><span class="kn">import</span> <span class="n">negate_inputs</span>

        <span class="k">return</span> <span class="n">negate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unary minus: -f returns f(-x) (input negation).</span>

<span class="sd">        This is the natural mathematical notation for input negation.</span>
<span class="sd">        For output negation (NOT), use ~f.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate_inputs</span><span class="p">()</span>

    <span class="c1"># =========================================================================</span>
    <span class="c1"># Property Testing (convenient methods)</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.is_linear">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_tests</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if function is linear (affine over GF(2)).</span>

<span class="sd">        Uses BLR linearity test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">PropertyTester</span>

        <span class="n">tester</span> <span class="o">=</span> <span class="n">PropertyTester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tester</span><span class="o">.</span><span class="n">blr_linearity_test</span><span class="p">(</span><span class="n">num_queries</span><span class="o">=</span><span class="n">num_tests</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_monotone">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_monotone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_monotone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_tests</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if function is monotone: x â‰¤ y implies f(x) â‰¤ f(y).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">PropertyTester</span>

        <span class="n">tester</span> <span class="o">=</span> <span class="n">PropertyTester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tester</span><span class="o">.</span><span class="n">monotonicity_test</span><span class="p">(</span><span class="n">num_queries</span><span class="o">=</span><span class="n">num_tests</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_junta">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_junta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_junta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if function depends on at most k variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">PropertyTester</span>

        <span class="n">tester</span> <span class="o">=</span> <span class="n">PropertyTester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tester</span><span class="o">.</span><span class="n">junta_test</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.is_global">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_global">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_set_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if f has alpha-small generalized influences (is alpha-global).</span>

<span class="sd">        A function is alpha-global if I_S(f) &lt;= alpha * E[f^2] for all small</span>
<span class="sd">        sets S. Global functions satisfy hypercontractivity under p-biased</span>
<span class="sd">        measures (Keevash-Lifshitz-Long-Minzer).</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha: Threshold for generalized influences</span>
<span class="sd">            max_set_size: Maximum |S| to check (default 3)</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if all generalized influences are &lt;= alpha * E[f^2]</span>

<span class="sd">        References:</span>
<span class="sd">            - Keevash, Lifshitz, Long &amp; Minzer (arXiv:1906.05039)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.global_hypercontractivity</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_alpha_global</span>

        <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">is_alpha_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">max_set_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="BooleanFunction.is_symmetric">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.is_symmetric">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_tests</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if function is symmetric (invariant under variable permutations).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">PropertyTester</span>

        <span class="n">tester</span> <span class="o">=</span> <span class="n">PropertyTester</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tester</span><span class="o">.</span><span class="n">symmetry_test</span><span class="p">(</span><span class="n">num_queries</span><span class="o">=</span><span class="n">num_tests</span><span class="p">)</span></div>


    <span class="c1"># =========================================================================</span>
    <span class="c1"># Additional Analysis Methods</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.hamming_weight">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.hamming_weight">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamming_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count number of 1s in truth table (outputs where f(x) = 1).</span>

<span class="sd">        Also called the &quot;weight&quot; or &quot;on-set size&quot; of the function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of inputs x where f(x) = 1</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bf.majority(3).hamming_weight()  # 4 (inputs with â‰¥2 ones)</span>
<span class="sd">            &gt;&gt;&gt; bf.AND(3).hamming_weight()       # 1 (only 111)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)))</span></div>


<div class="viewcode-block" id="BooleanFunction.support">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.support">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all inputs where f(x) = 1.</span>

<span class="sd">        Also called the &quot;on-set&quot; or &quot;satisfying assignments&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of input indices (as integers) where f(x) = 1</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bf.AND(2).support()  # [3] (binary 11)</span>
<span class="sd">            &gt;&gt;&gt; bf.OR(2).support()   # [1, 2, 3] (01, 10, 11)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">tt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="BooleanFunction.restriction">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.restriction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_vars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create restriction of f by fixing some variables.</span>

<span class="sd">        Alias for fix() with more standard mathematical terminology.</span>

<span class="sd">        Args:</span>
<span class="sd">            fixed_vars: Dict mapping variable index -&gt; fixed value (0 or 1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Restricted function on remaining variables</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.majority(3)</span>
<span class="sd">            &gt;&gt;&gt; g = f.restriction({0: 1})  # Fix xâ‚€=1, get 2-variable function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vars_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fixed_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">vals_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fixed_vars</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">vars_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vals_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">vars_list</span><span class="p">,</span> <span class="n">vals_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.cofactor">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.cofactor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cofactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Shannon cofactor f|_{x_i=b}.</span>

<span class="sd">        The cofactor is the restriction of f with variable i fixed to val.</span>
<span class="sd">        Shannon expansion: f = x_i Â· f|_{x_i=1} + (1-x_i) Â· f|_{x_i=0}</span>

<span class="sd">        Args:</span>
<span class="sd">            var: Variable index to fix</span>
<span class="sd">            val: Value to fix it to (0 or 1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Cofactor function (one fewer variable)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.majority(3)</span>
<span class="sd">            &gt;&gt;&gt; f0 = f.cofactor(0, 0)  # f with xâ‚€=0</span>
<span class="sd">            &gt;&gt;&gt; f1 = f.cofactor(0, 1)  # f with xâ‚€=1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.sensitivity_at">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.sensitivity_at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sensitivity_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sensitivity of f at input x.</span>

<span class="sd">        s(f, x) = |{i : f(x) â‰  f(x âŠ• eáµ¢)}|</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Input (as integer)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of sensitive coordinates at x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">):</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Flip bit i</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">!=</span> <span class="n">f_x</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>


<div class="viewcode-block" id="BooleanFunction.sensitivity">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.sensitivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sensitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sensitivity: s(f) = max_x s(f, x).</span>

<span class="sd">        Maximum number of sensitive bits over all inputs.</span>
<span class="sd">        Huang&#39;s theorem: s(f) â‰¥ âˆšdeg(f)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Maximum sensitivity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sensitivity_at</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">))</span></div>


    <span class="c1"># =========================================================================</span>
    <span class="c1"># Fluent/Chainable API Methods</span>
    <span class="c1"># =========================================================================</span>

<div class="viewcode-block" id="BooleanFunction.xor">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.xor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        XOR with another function (chainable).</span>

<span class="sd">        Equivalent to f ^ g but more readable in chains.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f.xor(g).fourier()</span>
<span class="sd">            &gt;&gt;&gt; f.restrict(0, 1).xor(g).influences()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">^</span> <span class="n">other</span></div>


<div class="viewcode-block" id="BooleanFunction.and_">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.and_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">and_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AND with another function (chainable).</span>

<span class="sd">        Named with underscore to avoid Python keyword conflict.</span>
<span class="sd">        Equivalent to f &amp; g.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&amp;</span> <span class="n">other</span></div>


<div class="viewcode-block" id="BooleanFunction.or_">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.or_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">or_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OR with another function (chainable).</span>

<span class="sd">        Named with underscore to avoid Python keyword conflict.</span>
<span class="sd">        Equivalent to f | g.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">|</span> <span class="n">other</span></div>


<div class="viewcode-block" id="BooleanFunction.not_">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.not_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">not_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Negate output (chainable).</span>

<span class="sd">        Equivalent to ~f. Returns function g where g(x) = NOT f(x).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span></div>


<div class="viewcode-block" id="BooleanFunction.apply_noise">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.apply_noise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply noise to get a new Boolean function via sampling.</span>

<span class="sd">        For each input x, outputs the majority vote of f(y) over multiple y,</span>
<span class="sd">        where each y is independently Ï-correlated with x.</span>

<span class="sd">        This gives a Boolean approximation to the noise operator T_Ï.</span>

<span class="sd">        Args:</span>
<span class="sd">            rho: Correlation parameter in [-1, 1]</span>
<span class="sd">            samples: Number of samples for majority vote (default: 100)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New Boolean function representing noisy version of f</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.parity(5)</span>
<span class="sd">            &gt;&gt;&gt; noisy_f = f.apply_noise(0.9)  # High noise correlation</span>
<span class="sd">            &gt;&gt;&gt; # Noisy version has lower degree (high-degree parts attenuated)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">rho</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must be in [-1, 1]&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># Sample multiple y&#39;s correlated with x, take majority of f(y)</span>
            <span class="n">votes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="c1"># Generate y: each bit equals x_i with prob (1+rho)/2</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">x_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">y_bit</span> <span class="o">=</span> <span class="n">x_bit</span>  <span class="c1"># Keep same</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">y_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x_bit</span>  <span class="c1"># Flip</span>
                    <span class="n">y</span> <span class="o">|=</span> <span class="n">y_bit</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">votes</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Majority vote</span>
            <span class="n">new_tt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">votes</span> <span class="o">&gt;</span> <span class="n">samples</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.noise_expectation">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.noise_expectation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">noise_expectation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute (T_Ï f)(x) = E_y[f(y)] for all inputs x.</span>

<span class="sd">        This returns the real-valued expectations, not a Boolean function.</span>
<span class="sd">        Useful for analysis of noise stability.</span>

<span class="sd">        In Fourier: (T_Ï f)^(S) = Ï^|S| Â· fÌ‚(S)</span>

<span class="sd">        Args:</span>
<span class="sd">            rho: Correlation parameter in [-1, 1]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of expectations E[f(y)|x] in {-1,+1} representation</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.parity(5)</span>
<span class="sd">            &gt;&gt;&gt; expectations = f.noise_expectation(0.9)</span>
<span class="sd">            &gt;&gt;&gt; # All values close to 0 (noise destroys parity signal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">rho</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;rho must be in [-1, 1]&quot;</span><span class="p">)</span>

        <span class="n">fourier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier</span><span class="p">()</span>

        <span class="c1"># Apply T_Ï: multiply each coefficient by Ï^|S|</span>
        <span class="n">new_fourier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fourier</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fourier</span><span class="p">)):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">new_fourier</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">fourier</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Convert back to values via inverse WHT</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.optimizations</span><span class="w"> </span><span class="kn">import</span> <span class="n">fast_walsh_hadamard</span>

        <span class="k">return</span> <span class="n">fast_walsh_hadamard</span><span class="p">(</span><span class="n">new_fourier</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="BooleanFunction.permute">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.permute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">permute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permute variables according to given permutation.</span>

<span class="sd">        Creates g where g(x_{perm[0]}, ..., x_{perm[n-1]}) = f(x_0, ..., x_{n-1}).</span>

<span class="sd">        Args:</span>
<span class="sd">            perm: List defining the permutation, where perm[i] = j means</span>
<span class="sd">                  variable i in the new function corresponds to variable j in self.</span>

<span class="sd">        Returns:</span>
<span class="sd">            New function with permuted variables</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.dictator(3, 0)  # f(x) = x_0</span>
<span class="sd">            &gt;&gt;&gt; g = f.permute([2, 0, 1])  # g(x) = x_2 (old position 0 â†’ new position 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Permutation must have </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> elements&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Permutation must be a valid permutation of 0..n-1&quot;</span><span class="p">)</span>

        <span class="c1"># Build new truth table</span>
        <span class="n">old_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># Apply permutation: bit i of new input â†’ bit perm[i] of old input</span>
            <span class="n">old_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">old_x</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">old_x</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.dual">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.dual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the dual function f*(x) = 1 - f(1-x) = NOT f(NOT x).</span>

<span class="sd">        The dual swaps the roles of AND and OR.</span>
<span class="sd">        For monotone functions, f* is the De Morgan dual.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dual function</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bf.AND(3).dual()  # Returns OR(3)</span>
<span class="sd">            &gt;&gt;&gt; bf.OR(3).dual()   # Returns AND(3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOT input, then f, then NOT output</span>
        <span class="k">return</span> <span class="o">~</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># -f = f(-x), then ~</span></div>


<div class="viewcode-block" id="BooleanFunction.extend">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.extend">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;dummy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend function to more variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_n: New number of variables (must be &gt;= current n)</span>
<span class="sd">            method: How to extend:</span>
<span class="sd">                    - &quot;dummy&quot;: New variables don&#39;t affect output (default)</span>
<span class="sd">                    - &quot;xor&quot;: XOR new variables with output</span>

<span class="sd">        Returns:</span>
<span class="sd">            Extended function</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.AND(2)  # f(x0, x1) = x0 AND x1</span>
<span class="sd">            &gt;&gt;&gt; g = f.extend(4)  # g(x0,x1,x2,x3) = x0 AND x1 (x2,x3 ignored)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="k">if</span> <span class="n">new_n</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_n (</span><span class="si">{</span><span class="n">new_n</span><span class="si">}</span><span class="s2">) must be &gt;= current n (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_n</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">old_tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representation</span><span class="p">(</span><span class="s2">&quot;truth_table&quot;</span><span class="p">)</span>
        <span class="n">new_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">new_n</span>
        <span class="n">new_tt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">new_size</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_size</span><span class="p">):</span>
            <span class="c1"># Extract lower n bits for the original function</span>
            <span class="n">orig_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">extra_bits</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">n</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;dummy&quot;</span><span class="p">:</span>
                <span class="n">new_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">orig_x</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;xor&quot;</span><span class="p">:</span>
                <span class="c1"># XOR with parity of extra bits</span>
                <span class="n">extra_parity</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">extra_bits</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="n">new_tt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tt</span><span class="p">[</span><span class="n">orig_x</span><span class="p">]</span> <span class="o">^</span> <span class="n">extra_parity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown extension method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BooleanFunctionFactory</span><span class="o">.</span><span class="n">from_truth_table</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">new_tt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">new_n</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooleanFunction.named">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.named">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">named</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BooleanFunction&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return same function with a descriptive name (for display/debugging).</span>

<span class="sd">        This is a fluent method that returns self with updated nickname.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; f = bf.majority(5).named(&quot;MAJ_5&quot;)</span>
<span class="sd">            &gt;&gt;&gt; f.nickname</span>
<span class="sd">            &#39;MAJ_5&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nickname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="BooleanFunction.pipe">
<a class="viewcode-back" href="../../../api/boofun.core.base.html#boofun.BooleanFunction.pipe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply an arbitrary function to self (for maximum fluency).</span>

<span class="sd">        Allows inserting custom transformations into a chain.</span>

<span class="sd">        Args:</span>
<span class="sd">            func: Function to apply, receives self as first argument</span>
<span class="sd">            *args, **kwargs: Additional arguments to func</span>

<span class="sd">        Returns:</span>
<span class="sd">            Result of func(self, *args, **kwargs)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; def custom_transform(f, scale):</span>
<span class="sd">            ...     return f.apply_noise(scale)</span>
<span class="sd">            &gt;&gt;&gt; f.pipe(custom_transform, 0.9).fourier()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024-2026, Gabriel Taboada.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>